defmodule Mandarin.Designer do
  @moduledoc """
  Convenience functions to design an application (schemas, contexts and HTML)
  in a programmatic way.

  This is equivalent to using the Phoenix and Mandarin generators, but with a nicer API
  which allows you to use the full power of the Elixir language to run the generators
  instead of relying on custom bash scripts or manually running the generators.
  """

  alias Mandarin.Designer.Params
  alias Mandarin.Designer.Timestamp

  require Logger

  @migrations_path "priv/repo/migrations"

  @migrations_begin_marker_contents """
  # This file marks the BEGINNING of the files generated by EctoDesigner
  """

  @migrations_end_marker_contents """
  # This file marks the END of the files generated by EctoDesigner
  """

  @doc """
  Create a foreign key reference
  """
  def references(foreign_table) do
    {:references, foreign_table}
  end

  @doc """
  Tag a field as unique.
  """
  def unique(type) do
    {:unique, type}
  end

  @doc """
  Run a function (`fun`) which may create migration files and add marker files
  to migrations path to delimit which migrations were generated.
  This makes it easier to see which migrations were generated as a group.

  The migration files will contain the `tag` in the file name, so you may want
  to make it descriptive.
  """
  def with_ecto_design_markers(tag, migrations_path \\ @migrations_path, fun) do
    begin_file_name =
      Path.join(migrations_path, "#{Timestamp.timestamp()}__begin_ecto_designer__#{tag}__.txt")

    Timestamp.with_timestamp_update_if_needed(migrations_path, fn ->
      File.write!(begin_file_name, @migrations_begin_marker_contents)
    end)

    fun.()

    end_file_name =
      Path.join(migrations_path, "#{Timestamp.timestamp()}__end_ecto_designer__#{tag}__.txt")

    Timestamp.with_timestamp_update_if_needed(migrations_path, fn ->
      File.write!(end_file_name, @migrations_end_marker_contents)
    end)
  end

  # Mandarin generators

  @doc """
  Generate a mandarin schema (without generating a context or any web interface).

  This might be useful for schemas that are meant to act only as `join_through` tables
  for many-to-many relations. These schemas don't require a context or a web interface.
  In fact, the user is not meant to interact with them directly.
  Ecto will be capable of using them when required if the schemas are configured correctly.
  """
  @spec generate_mandarin_schema(Params.t(), String.t()) :: :ok
  def generate_mandarin_schema(params, migrations_path \\ @migrations_path) do
    args = params_to_arguments(params)
    # The schema name is of the form `Context.Schema`
    schema_name = Module.concat(params.context, params.alias) |> inspect()

    Timestamp.with_timestamp_update_if_needed(migrations_path, fn ->
      Mix.Tasks.Mandarin.Gen.Schema.run([schema_name] ++ args)
    end)

    :ok
  end

  @doc """
  Generate a mandarin context (without generating a web interface)
  """
  @spec generate_mandarin_context(Params.t(), String.t()) :: :ok
  def generate_mandarin_context(params, migrations_path \\ @migrations_path) do
    args = params_to_arguments(params)
    context = inspect(params.context)
    name = inspect(params.alias)

    Timestamp.with_timestamp_update_if_needed(migrations_path, fn ->
      Mix.Tasks.Mandarin.Gen.Context.run([context, name] ++ args)
    end)

    :ok
  end

  @doc """
  Generate a mandarin context (without generating a web interface).

  If the params belong to a `join_through` table, this is the same
  as running `generate_mandarin_schema(params)`.
  """
  @spec generate_mandarin_html(Params.t(), Keyword.t()) :: :ok
  def generate_mandarin_html(params, opts \\ []) do
    migrations_path = Keyword.get(opts, :migrations_path, @migrations_path)
    user = Keyword.get(opts, :user, nil)

    if params.is_join_through? do
      generate_mandarin_schema(params, migrations_path)
    else
      do_generate_mandarin_html(params, migrations_path, user)
    end
  end

  defp do_generate_mandarin_html(params, migrations_path, user) do
    args = params_to_arguments(params)
    context = inspect(params.context)
    name = inspect(params.alias)

    user_params = (user && ["--user", user]) || []

    Timestamp.with_timestamp_update_if_needed(migrations_path, fn ->
      Mix.Tasks.Mandarin.Gen.Html.run([context, name] ++ args ++ user_params)
    end)

    :ok
  end

  @doc """
  Generate mandarin web interfaces (schemas, context and the web part) for a list of params.

  If the any params belong to a `join_through` table, this will run
  `generate_mandarin_schema(params)` for those params.
  """
  def generate_mandarin_html_for_all(list_of_params, tag, opts) when tag != "" do
    with_ecto_design_markers(tag, fn ->
      for params <- list_of_params do
        generate_mandarin_html(params, opts)
      end
    end)
  end

  # Helpers

  defp make_fields(fields) do
    for {name, value} <- fields do
      string_value =
        case value do
          {:references, table} -> "references:#{table}"
          {:unique, type} -> "#{type}:unique"
          other -> to_string(other)
        end

      "#{name}:#{string_value}"
    end
  end

  defp params_to_arguments(params) do
    # Convert params attributes into arguments that can be given
    # to the phoenix (or mandarin/vertical_phoenix) generators
    maybe_binary_id =
      case params.binary_id do
        true -> ["--binary-id"]
        false -> []
      end

    maybe_migration =
      case params.generate_migration? do
        true -> []
        false -> ["--no-migration"]
      end

    maybe_yes =
      case params.yes? do
        true -> ["--yes"]
        false -> []
      end

    fields = make_fields(params.fields)
    [params.table] ++ fields ++ maybe_binary_id ++ maybe_migration ++ maybe_yes
  end

  @doc """
  Generate an authentication context.

  Receives the following required arguments:

    * `context` - the context module to generate as module alias
      (e.g. `Accounts`; not a string)

    * `user` - the name of the user schema as module alias
      (e.g. `User`; not a string)

    * `user_table` - the name of the user table as a string (e.g. `"users"`)

  Supports the following options:

    * `:binary_id` (optional) - equivalent to the `--binary-id` command line switch.
      Controls whether the user schema uses binary ids or sequential ids.

  """
  def gen_auth(context, user, user_table, opts \\ [])
        when is_atom(context) and is_atom(user) and is_binary(user_table) do

    binary_id? = Keyword.get(opts, :binary_id)
    maybe_binary_id = (binary_id? && ["--binary-id"]) || []

    context_as_binary = inspect(context)
    user_as_binary = inspect(user)

    params = [context_as_binary, user_as_binary, user_table] ++ maybe_binary_id

    Mix.Tasks.Mandarin.Gen.Auth.run(params)
  end
end
